<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>The Wobbly Watcher</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Babel for in-browser compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Creepster&family=Vt323&display=swap" rel="stylesheet">
    
    <style>
      body {
        background-color: #0f0f0f;
        color: #e0e0e0;
        overflow: hidden;
        touch-action: none;
      }
      .font-creepy { font-family: 'Creepster', cursive; }
      .font-retro { font-family: 'Vt323', monospace; }
      
      .scanlines::before {
        content: " ";
        display: block;
        position: absolute;
        top: 0; left: 0; bottom: 0; right: 0;
        background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
        z-index: 10;
        background-size: 100% 2px, 3px 100%;
        pointer-events: none;
      }
      
      @keyframes flicker {
        0% { opacity: 0.97; } 5% { opacity: 0.95; } 10% { opacity: 0.9; } 15% { opacity: 0.95; } 20% { opacity: 0.99; } 50% { opacity: 0.95; } 80% { opacity: 0.9; } 100% { opacity: 0.97; }
      }
      .animate-flicker { animation: flicker 0.15s infinite; }

      @keyframes shake {
        0% { transform: translate(1px, 1px) rotate(0deg); }
        10% { transform: translate(-1px, -2px) rotate(-1deg); }
        20% { transform: translate(-3px, 0px) rotate(1deg); }
        30% { transform: translate(3px, 2px) rotate(0deg); }
        40% { transform: translate(1px, -1px) rotate(1deg); }
        50% { transform: translate(-1px, 2px) rotate(-1deg); }
        60% { transform: translate(-3px, 1px) rotate(0deg); }
        70% { transform: translate(3px, 1px) rotate(-1deg); }
        80% { transform: translate(-1px, -1px) rotate(1deg); }
        90% { transform: translate(1px, 2px) rotate(0deg); }
        100% { transform: translate(1px, -2px) rotate(-1deg); }
      }
      .animate-shake { animation: shake 0.5s infinite; }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel" data-presets="typescript,react" data-type="module">
      import React, { useState, useEffect, useRef, useCallback } from 'https://esm.sh/react@18.2.0?dev';
      import { createRoot } from 'https://esm.sh/react-dom@18.2.0/client?dev';
      import { Skull, Volume2, VolumeX, Ghost } from 'https://esm.sh/lucide-react@0.294.0?dev';

      // --- TYPES (Inlined) ---
      type GameState = 'START' | 'PLAYING' | 'GAME_OVER';

      interface Position {
        x: number;
        y: number;
      }

      interface Entity extends Position {
        radius: number;
        color: string;
      }

      interface Player extends Entity {
        baseSpeed: number;
        speed: number;
        buffs: {
          speed: number;
          shrink: number;
        };
      }

      interface Creature extends Entity {
        baseSpeed: number;
        speed: number;
        angle: number;
        wobbleIntensity: number;
        frozenTimer: number;
      }

      interface Particle extends Position {
        vx: number;
        vy: number;
        life: number;
        color: string;
        size: number;
        type?: 'TRAIL' | 'ENV' | 'EXPLOSION';
      }

      type BuffType = 'SPEED' | 'SHRINK' | 'FREEZE';

      interface Buff extends Entity {
        type: BuffType;
        life: number;
        maxLife: number;
      }

      type HazardType = 'BOMB' | 'SPIKE';

      interface Hazard extends Entity {
        type: HazardType;
        timer: number;
        state: 'WARNING' | 'ACTIVE';
      }

      // --- CONSTANTS (Inlined) ---
      const GAME_CONSTANTS = {
        PLAYER_RADIUS: 15,
        PLAYER_BASE_SPEED: 0.15,
        PLAYER_BUFF_SPEED: 0.25,
        PLAYER_SHRINK_RADIUS: 8,
        
        CREATURE_RADIUS: 25,
        CREATURE_BASE_SPEED: 2.5,
        CREATURE_SPEED_INCREMENT: 0.0005,
        
        TAUNT_INTERVAL_MIN: 3000,
        TAUNT_INTERVAL_MAX: 8000,

        BUFF_SPAWN_CHANCE: 0.002,
        HAZARD_SPAWN_CHANCE_START: 0.005,
        HAZARD_SPAWN_INCREASE: 0.0001,

        BOMB_FUSE: 120,
        BOMB_RADIUS: 80,
        SPIKE_DURATION: 300,
        SPIKE_RADIUS: 20,
      };

      const BUFF_COLORS = {
        SPEED: '#00FFFF',
        SHRINK: '#FF00FF',
        FREEZE: '#0000FF',
      };

      const HAZARD_COLORS = {
        BOMB: '#FF4500',
        SPIKE: '#808080',
      };

      const CREATURE_TAUNTS = [
        "I just want to count your teeth!",
        "Why are you so squishy?",
        "Stop running, I made cookies! (With bugs)",
        "Do your bones rattle when you shake?",
        "Let me smell your fear... smells like popcorn.",
        "I promise I won't bite... hard.",
        "Hug time!",
        "Are you edible? Asking for a friend.",
        "You run funny. I like it.",
        "Wait! You dropped your shadow!",
        "Squish squish squish.",
        "I have a present for you! It's slime!",
        "Don't be shy, I'm just a nightmare!",
        "My mom says I'm handsome!",
        "Stop moving, you're making me dizzy!",
      ];

      const CREATURE_COLORS = [
        '#FF0055', '#A020F0', '#32CD32', '#FF4500',
      ];

      // --- SOUND ENGINE (Inlined) ---
      class SoundEngine {
        ctx = null;
        gainNode = null;
        isMuted = false;

        init() {
          if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.gainNode = this.ctx.createGain();
            this.gainNode.connect(this.ctx.destination);
            this.gainNode.gain.value = 0.3;
          }
          if (this.ctx.state === 'suspended') {
            this.ctx.resume();
          }
        }

        setMute(muted) {
          this.isMuted = muted;
          if (this.gainNode) {
            this.gainNode.gain.value = muted ? 0 : 0.3;
          }
        }

        playTone(freq, type, duration, startTime = 0, volume = 1) {
          if (!this.ctx || !this.gainNode || this.isMuted) return;

          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();

          osc.type = type;
          osc.frequency.setValueAtTime(freq, this.ctx.currentTime + startTime);

          gain.gain.setValueAtTime(volume, this.ctx.currentTime + startTime);
          gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + startTime + duration);

          osc.connect(gain);
          gain.connect(this.gainNode);

          osc.start(this.ctx.currentTime + startTime);
          osc.stop(this.ctx.currentTime + startTime + duration);
        }

        playStart() {
          this.init();
          this.playTone(440, 'sine', 0.5, 0);       
          this.playTone(554.37, 'sine', 0.5, 0.1);  
          this.playTone(659.25, 'sine', 0.5, 0.2);  
          this.playTone(880, 'triangle', 0.8, 0.3); 
        }

        playTaunt() {
          if (!this.ctx) return;
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          
          osc.type = 'sawtooth';
          osc.frequency.setValueAtTime(300, this.ctx.currentTime);
          osc.frequency.linearRampToValueAtTime(800, this.ctx.currentTime + 0.1);
          osc.frequency.linearRampToValueAtTime(200, this.ctx.currentTime + 0.2);
          
          const lfo = this.ctx.createOscillator();
          lfo.type = 'square';
          lfo.frequency.value = 50;
          const lfoGain = this.ctx.createGain();
          lfoGain.gain.value = 500;
          lfo.connect(lfoGain);
          lfoGain.connect(osc.frequency);
          lfo.start();
          lfo.stop(this.ctx.currentTime + 0.3);

          gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);

          osc.connect(gain);
          gain.connect(this.gainNode); 
          osc.start();
          osc.stop(this.ctx.currentTime + 0.3);
        }

        playGameOver() {
          if (!this.ctx) return;
          this.playTone(100, 'sawtooth', 1.0, 0, 0.5);
          this.playTone(106, 'sawtooth', 1.0, 0, 0.5); 
          this.playTone(50, 'square', 1.5, 0, 0.5);
          
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.type = 'triangle';
          osc.frequency.setValueAtTime(800, this.ctx.currentTime);
          osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 1.5);
          
          gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1.5);
          
          osc.connect(gain);
          gain.connect(this.gainNode);
          osc.start();
          osc.stop(this.ctx.currentTime + 1.5);
        }

        playBuffPickup() {
          this.playTone(880, 'sine', 0.2, 0, 0.3);
          this.playTone(1108, 'sine', 0.2, 0.1, 0.3);
          this.playTone(1320, 'sine', 0.4, 0.2, 0.3);
        }

        playExplosion() {
          if (!this.ctx) return;
          const bufferSize = this.ctx.sampleRate * 0.5;
          const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
          const data = buffer.getChannelData(0);
          for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
          }
          const noise = this.ctx.createBufferSource();
          noise.buffer = buffer;
          const filter = this.ctx.createBiquadFilter();
          filter.type = 'lowpass';
          filter.frequency.value = 1000;
          filter.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.4);
          const gain = this.ctx.createGain();
          gain.gain.setValueAtTime(1, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.4);
          noise.connect(filter);
          filter.connect(gain);
          gain.connect(this.gainNode);
          noise.start();
        }

        playFuse() {
          this.playTone(600, 'square', 0.05, 0, 0.2);
        }

        playFreeze() {
          if (!this.ctx) return;
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(2000, this.ctx.currentTime);
          osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.5);
          gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
          osc.connect(gain);
          gain.connect(this.gainNode);
          osc.start();
          osc.stop(this.ctx.currentTime + 0.5);
        }
      }

      const soundEngine = new SoundEngine();

      // --- GAME CANVAS COMPONENT (Inlined) ---
      const GameCanvas = ({ gameState, onGameOver, setTaunt }) => {
        const canvasRef = useRef(null);
        const requestRef = useRef(0);
        const scoreRef = useRef(0);

        const playerRef = useRef({
          x: 0, y: 0,
          radius: GAME_CONSTANTS.PLAYER_RADIUS,
          color: '#4ADE80',
          baseSpeed: GAME_CONSTANTS.PLAYER_BASE_SPEED,
          speed: GAME_CONSTANTS.PLAYER_BASE_SPEED,
          buffs: { speed: 0, shrink: 0 }
        });

        const creatureRef = useRef({
          x: -100, y: -100,
          radius: GAME_CONSTANTS.CREATURE_RADIUS,
          color: CREATURE_COLORS[0],
          baseSpeed: GAME_CONSTANTS.CREATURE_BASE_SPEED,
          speed: GAME_CONSTANTS.CREATURE_BASE_SPEED,
          angle: 0,
          wobbleIntensity: 5,
          frozenTimer: 0
        });

        const mouseRef = useRef({ x: 0, y: 0 });
        const particlesRef = useRef([]);
        const buffsRef = useRef([]);
        const hazardsRef = useRef([]);

        const lastTauntTime = useRef(0);
        const nextTauntInterval = useRef(2000);
        const difficultyFactor = useRef(1);
        const [dimensions, setDimensions] = useState({ width: window.innerWidth, height: window.innerHeight });

        useEffect(() => {
          const handleResize = () => setDimensions({ width: window.innerWidth, height: window.innerHeight });
          window.addEventListener('resize', handleResize);
          return () => window.removeEventListener('resize', handleResize);
        }, []);

        useEffect(() => {
          if (gameState === 'PLAYING') {
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            scoreRef.current = 0;
            difficultyFactor.current = 1;

            playerRef.current = {
              x: centerX,
              y: centerY,
              radius: GAME_CONSTANTS.PLAYER_RADIUS,
              color: '#4ADE80',
              baseSpeed: GAME_CONSTANTS.PLAYER_BASE_SPEED,
              speed: GAME_CONSTANTS.PLAYER_BASE_SPEED,
              buffs: { speed: 0, shrink: 0 }
            };

            mouseRef.current = { x: centerX, y: centerY };

            const spawnAngle = Math.random() * Math.PI * 2;
            const spawnDist = Math.max(window.innerWidth, window.innerHeight);
            creatureRef.current = {
              x: centerX + Math.cos(spawnAngle) * spawnDist,
              y: centerY + Math.sin(spawnAngle) * spawnDist,
              radius: GAME_CONSTANTS.CREATURE_RADIUS,
              color: CREATURE_COLORS[Math.floor(Math.random() * CREATURE_COLORS.length)],
              baseSpeed: GAME_CONSTANTS.CREATURE_BASE_SPEED,
              speed: GAME_CONSTANTS.CREATURE_BASE_SPEED,
              angle: 0,
              wobbleIntensity: 5,
              frozenTimer: 0
            };

            const envParticles = [];
            for (let i = 0; i < 50; i++) {
              envParticles.push({
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight,
                vx: (Math.random() - 0.5) * 0.2,
                vy: (Math.random() - 0.5) * 0.2,
                life: 1,
                color: '#ffffff',
                size: Math.random() * 2,
                type: 'ENV'
              });
            }

            particlesRef.current = envParticles;
            buffsRef.current = [];
            hazardsRef.current = [];
            lastTauntTime.current = Date.now();
          }
        }, [gameState]);

        useEffect(() => {
          const handleMouseMove = (e) => { mouseRef.current = { x: e.clientX, y: e.clientY }; };
          const handleTouchMove = (e) => {
            e.preventDefault();
            mouseRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          };
          window.addEventListener('mousemove', handleMouseMove);
          window.addEventListener('touchmove', handleTouchMove, { passive: false });
          return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('touchmove', handleTouchMove);
          };
        }, []);

        const spawnBuff = (width, height) => {
          const types = ['SPEED', 'SHRINK', 'FREEZE'];
          const type = types[Math.floor(Math.random() * types.length)];
          buffsRef.current.push({
            x: Math.random() * (width - 100) + 50,
            y: Math.random() * (height - 100) + 50,
            radius: 10,
            color: BUFF_COLORS[type],
            type: type,
            life: 600,
            maxLife: 600
          });
        };

        const spawnHazard = (width, height) => {
          const types = ['BOMB', 'SPIKE'];
          const type = types[Math.floor(Math.random() * types.length)];
          const margin = 50;
          hazardsRef.current.push({
            x: Math.random() * (width - margin * 2) + margin,
            y: Math.random() * (height - margin * 2) + margin,
            radius: type === 'BOMB' ? GAME_CONSTANTS.BOMB_RADIUS : GAME_CONSTANTS.SPIKE_RADIUS,
            color: HAZARD_COLORS[type],
            type: type,
            timer: type === 'BOMB' ? GAME_CONSTANTS.BOMB_FUSE : GAME_CONSTANTS.SPIKE_DURATION,
            state: 'WARNING'
          });
        };

        const createExplosion = (x, y, color, count) => {
            for(let i=0; i<count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                particlesRef.current.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    color: color,
                    size: Math.random() * 4 + 2,
                    type: 'EXPLOSION'
                });
            }
        }

        const loop = useCallback(() => {
          if (gameState !== 'PLAYING') return;
          const canvas = canvasRef.current;
          if (!canvas) return;
          const ctx = canvas.getContext('2d');
          if (!ctx) return;

          const now = Date.now();
          const width = dimensions.width;
          const height = dimensions.height;

          scoreRef.current++;
          if (scoreRef.current % 300 === 0) difficultyFactor.current += 0.05;

          ctx.clearRect(0, 0, width, height);

          const player = playerRef.current;
          const creature = creatureRef.current;

          if (player.buffs.speed > 0) player.buffs.speed--;
          if (player.buffs.shrink > 0) player.buffs.shrink--;

          player.speed = player.buffs.speed > 0 ? GAME_CONSTANTS.PLAYER_BUFF_SPEED : GAME_CONSTANTS.PLAYER_BASE_SPEED;
          player.radius = player.buffs.shrink > 0 ? GAME_CONSTANTS.PLAYER_SHRINK_RADIUS : GAME_CONSTANTS.PLAYER_RADIUS;

          const dx = mouseRef.current.x - player.x;
          const dy = mouseRef.current.y - player.y;
          player.x += dx * player.speed;
          player.y += dy * player.speed;

          if (scoreRef.current % 4 === 0) {
            particlesRef.current.push({
              x: player.x + (Math.random() - 0.5) * 10,
              y: player.y + (Math.random() - 0.5) * 10,
              vx: (Math.random() - 0.5) * 0.5,
              vy: (Math.random() - 0.5) * 0.5,
              life: 0.8,
              color: player.buffs.speed > 0 ? BUFF_COLORS.SPEED : (player.buffs.shrink > 0 ? BUFF_COLORS.SHRINK : player.color),
              size: player.radius / 3,
              type: 'TRAIL'
            });
          }

          if (Math.random() < GAME_CONSTANTS.BUFF_SPAWN_CHANCE) spawnBuff(width, height);
          
          buffsRef.current.forEach((buff) => {
            buff.life--;
            const floatY = Math.sin(now * 0.005 + buff.x) * 5;
            ctx.save();
            ctx.translate(buff.x, buff.y + floatY);
            ctx.fillStyle = buff.color;
            ctx.shadowBlur = 10;
            ctx.shadowColor = buff.color;
            ctx.beginPath();
            ctx.arc(0, 0, buff.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            const dist = Math.hypot(player.x - buff.x, player.y - buff.y);
            if (dist < player.radius + buff.radius) {
              soundEngine.playBuffPickup();
              if (buff.type === 'SPEED') player.buffs.speed = 300;
              if (buff.type === 'SHRINK') player.buffs.shrink = 300;
              if (buff.type === 'FREEZE') {
                  creature.frozenTimer = 180;
                  soundEngine.playFreeze();
              }
              buff.life = 0;
            }
          });
          buffsRef.current = buffsRef.current.filter(b => b.life > 0);

          const currentHazardChance = GAME_CONSTANTS.HAZARD_SPAWN_CHANCE_START + (GAME_CONSTANTS.HAZARD_SPAWN_INCREASE * scoreRef.current);
          if (Math.random() < currentHazardChance) spawnHazard(width, height);
          
          hazardsRef.current.forEach(hazard => {
              hazard.timer--;
              ctx.save();
              ctx.translate(hazard.x, hazard.y);
              
              if (hazard.type === 'BOMB') {
                  if (hazard.timer > 0) {
                      const flash = Math.floor(hazard.timer / 10) % 2 === 0;
                      ctx.fillStyle = flash ? '#FFF' : hazard.color;
                      ctx.beginPath();
                      ctx.arc(0, 0, 15, 0, Math.PI*2);
                      ctx.fill();
                      ctx.fillStyle = '#FFF';
                      ctx.font = '12px monospace';
                      ctx.fillText((hazard.timer/60).toFixed(1), -10, -20);
                      if (hazard.timer % 30 === 0) soundEngine.playFuse();
                  } else if (hazard.timer === 0) {
                      soundEngine.playExplosion();
                      createExplosion(hazard.x, hazard.y, HAZARD_COLORS.BOMB, 20);
                      const dist = Math.hypot(player.x - hazard.x, player.y - hazard.y);
                      if (dist < hazard.radius) onGameOver(scoreRef.current);
                  } else {
                       if (hazard.timer > -10) {
                           ctx.fillStyle = HAZARD_COLORS.BOMB;
                           ctx.globalAlpha = 0.5;
                           ctx.beginPath();
                           ctx.arc(0, 0, hazard.radius, 0, Math.PI*2);
                           ctx.fill();
                           ctx.globalAlpha = 1;
                       }
                  }
              } else if (hazard.type === 'SPIKE') {
                   ctx.fillStyle = hazard.color;
                   ctx.beginPath();
                   for(let i=0; i<5; i++) {
                       const angle = (Math.PI * 2 * i) / 5;
                       const outer = hazard.radius;
                       const inner = hazard.radius / 2;
                       ctx.lineTo(Math.cos(angle) * outer, Math.sin(angle) * outer);
                       ctx.lineTo(Math.cos(angle + Math.PI/5) * inner, Math.sin(angle + Math.PI/5) * inner);
                   }
                   ctx.closePath();
                   ctx.fill();
                   const dist = Math.hypot(player.x - hazard.x, player.y - hazard.y);
                   if (dist < player.radius + hazard.radius - 5) onGameOver(scoreRef.current);
              }
              ctx.restore();
          });
          hazardsRef.current = hazardsRef.current.filter(h => {
              if (h.type === 'BOMB') return h.timer > -15;
              if (h.type === 'SPIKE') return h.timer > 0;
              return false;
          });

          if (creature.frozenTimer > 0) {
              creature.frozenTimer--;
              creature.x += (Math.random()-0.5) * 2;
              creature.y += (Math.random()-0.5) * 2;
              ctx.strokeStyle = '#00FFFF';
              ctx.lineWidth = 2;
              ctx.strokeRect(creature.x - creature.radius - 5, creature.y - creature.radius - 5, (creature.radius+5)*2, (creature.radius+5)*2);
          } else {
              const angleToPlayer = Math.atan2(player.y - creature.y, player.x - creature.x);
              const speed = (creature.baseSpeed + (scoreRef.current * GAME_CONSTANTS.CREATURE_SPEED_INCREMENT)) * difficultyFactor.current;
              creature.angle += 0.1;
              const wobbleIntensity = creature.wobbleIntensity * difficultyFactor.current;
              const wobbleOffset = Math.sin(creature.angle) * wobbleIntensity;
              const moveX = Math.cos(angleToPlayer) * speed - Math.sin(angleToPlayer) * (wobbleOffset * 0.1);
              const moveY = Math.sin(angleToPlayer) * speed + Math.cos(angleToPlayer) * (wobbleOffset * 0.1);

              creature.x += moveX;
              creature.y += moveY;
              
              const dist = Math.hypot(player.x - creature.x, player.y - creature.y);
              if (dist < player.radius + creature.radius - 5) {
                  onGameOver(scoreRef.current);
                  return; 
              }
          }

          if (scoreRef.current % 5 === 0 && creature.frozenTimer <= 0) {
             particlesRef.current.push({
              x: creature.x + (Math.random() - 0.5) * 20,
              y: creature.y + (Math.random() - 0.5) * 20,
              vx: (Math.random() - 0.5) * 1,
              vy: (Math.random() - 0.5) * 1,
              life: 1.0,
              color: creature.color,
              size: Math.random() * 8 + 2,
              type: 'TRAIL'
            });
          }

          particlesRef.current.forEach(p => {
              if (p.type === 'ENV') {
                  p.x += p.vx;
                  p.y += p.vy;
                  if (p.x < 0) p.x = width;
                  if (p.x > width) p.x = 0;
                  if (p.y < 0) p.y = height;
                  if (p.y > height) p.y = 0;
                  const dx = p.x - creature.x;
                  const dy = p.y - creature.y;
                  const dist = Math.hypot(dx, dy);
                  if (dist < 150) {
                      const angle = Math.atan2(dy, dx);
                      p.x += Math.cos(angle) * 5;
                      p.y += Math.sin(angle) * 5;
                  }
                  ctx.fillStyle = p.color;
                  ctx.globalAlpha = 0.2;
                  ctx.beginPath();
                  ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                  ctx.fill();
                  ctx.globalAlpha = 1;
              } else {
                  p.x += p.vx;
                  p.y += p.vy;
                  p.life -= 0.02;
                  p.size *= 0.95;
                  ctx.fillStyle = p.color;
                  ctx.globalAlpha = p.life * 0.8;
                  ctx.beginPath();
                  ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                  ctx.fill();
                  ctx.globalAlpha = 1;
              }
          });
          particlesRef.current = particlesRef.current.filter(p => p.type === 'ENV' || p.life > 0);

          ctx.save();
          ctx.translate(player.x, player.y);
          ctx.fillStyle = player.color;
          if (player.buffs.speed > 0) {
              ctx.shadowBlur = 20;
              ctx.shadowColor = BUFF_COLORS.SPEED;
          } else if (player.buffs.shrink > 0) {
              ctx.shadowBlur = 10;
              ctx.shadowColor = BUFF_COLORS.SHRINK;
          } else {
              ctx.shadowBlur = 15;
              ctx.shadowColor = player.color;
          }
          ctx.beginPath();
          ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
          ctx.fill();
          const ang = Math.atan2(creature.y - player.y, creature.x - player.x);
          const eyeOffset = player.radius / 3;
          const pupilOffset = 3;
          ctx.fillStyle = 'white';
          ctx.beginPath(); ctx.arc(-eyeOffset, -2, player.radius/3, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(eyeOffset, -2, player.radius/3, 0, Math.PI*2); ctx.fill();
          ctx.fillStyle = 'black';
          ctx.beginPath(); ctx.arc(-eyeOffset + Math.cos(ang)*pupilOffset, -2 + Math.sin(ang)*pupilOffset, 2, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(eyeOffset + Math.cos(ang)*pupilOffset, -2 + Math.sin(ang)*pupilOffset, 2, 0, Math.PI*2); ctx.fill();
          if (Math.hypot(player.x - creature.x, player.y - creature.y) < 200) {
              ctx.fillStyle = '#00FFFF';
              ctx.beginPath();
              ctx.arc(player.radius, -player.radius, 4, 0, Math.PI*2);
              ctx.fill();
          }
          ctx.restore();

          ctx.save();
          ctx.translate(creature.x, creature.y);
          const pulse = 1 + Math.sin(now * 0.01) * 0.1;
          ctx.scale(pulse, pulse);
          ctx.fillStyle = creature.frozenTimer > 0 ? '#88CCFF' : creature.color;
          ctx.shadowBlur = 20;
          ctx.shadowColor = creature.color;
          ctx.beginPath();
          for (let i = 0; i <= 360; i += 10) {
            const rad = (i * Math.PI) / 180;
            const r = creature.radius + Math.sin(rad * 5 + now * 0.01) * 5 + Math.cos(rad * 3) * 3;
            const x = Math.cos(rad) * r;
            const y = Math.sin(rad) * r;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = 'white';
          ctx.beginPath(); ctx.arc(0, -5, 10, 0, Math.PI * 2); ctx.fill();
          ctx.fillStyle = 'black';
          ctx.beginPath(); ctx.arc(Math.random() * 4 - 2, -5 + Math.random() * 4 - 2, 3, 0, Math.PI * 2); ctx.fill();
          ctx.fillStyle = '#fff';
          ctx.beginPath(); ctx.arc(-15, 5, 4, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(15, 10, 6, 0, Math.PI*2); ctx.fill();
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(0, 10, 10, 0, Math.PI, false);
          ctx.stroke();
          ctx.restore();

          if (now - lastTauntTime.current > nextTauntInterval.current) {
            const taunt = CREATURE_TAUNTS[Math.floor(Math.random() * CREATURE_TAUNTS.length)];
            setTaunt(taunt);
            soundEngine.playTaunt();
            setTimeout(() => setTaunt(null), 3000);
            lastTauntTime.current = now;
            nextTauntInterval.current = Math.random() * (GAME_CONSTANTS.TAUNT_INTERVAL_MAX - GAME_CONSTANTS.TAUNT_INTERVAL_MIN) + GAME_CONSTANTS.TAUNT_INTERVAL_MIN;
          }

          requestRef.current = requestAnimationFrame(loop);
        }, [gameState, dimensions, onGameOver, setTaunt]);

        useEffect(() => {
          requestRef.current = requestAnimationFrame(loop);
          return () => {
            if (requestRef.current) cancelAnimationFrame(requestRef.current);
          };
        }, [loop]);

        return (
          <>
            <canvas
              ref={canvasRef}
              width={dimensions.width}
              height={dimensions.height}
              className="fixed inset-0 cursor-none z-0"
            />
            <div className="fixed top-4 left-4 z-10 font-retro text-2xl text-white opacity-50 pointer-events-none">
               SURVIVAL TIME: {(scoreRef.current / 60).toFixed(1)}s
            </div>
          </>
        );
      };

      // --- APP COMPONENT (Inlined) ---
      const App = () => {
        const [gameState, setGameState] = useState('START');
        const [finalScore, setFinalScore] = useState(0);
        const [taunt, setTaunt] = useState(null);
        const [muted, setMuted] = useState(false);

        const toggleMute = () => {
          const newMute = !muted;
          setMuted(newMute);
          soundEngine.setMute(newMute);
        };

        const startGame = () => {
          soundEngine.playStart();
          setGameState('PLAYING');
          setTaunt(null);
        };

        const handleGameOver = (frames) => {
          setFinalScore(frames);
          setGameState('GAME_OVER');
          soundEngine.playGameOver();
        };

        const scoreSeconds = (finalScore / 60).toFixed(2);

        return (
          <div className="relative w-full h-screen overflow-hidden bg-neutral-900 scanlines select-none text-white">
            <button 
              onClick={toggleMute}
              className="fixed top-4 right-4 z-50 p-2 bg-black/50 rounded-full hover:bg-white/10 transition-colors"
            >
              {muted ? <VolumeX size={24} /> : <Volume2 size={24} />}
            </button>

            <GameCanvas 
              gameState={gameState} 
              onGameOver={handleGameOver}
              setTaunt={setTaunt} 
            />

            {taunt && gameState === 'PLAYING' && (
              <div className="fixed top-1/4 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-20 pointer-events-none w-full text-center px-4">
                <h2 className="text-3xl md:text-5xl font-creepy text-red-500 animate-shake drop-shadow-[0_5px_5px_rgba(0,0,0,0.8)]">
                  "{taunt}"
                </h2>
              </div>
            )}

            {gameState === 'START' && (
              <div className="absolute inset-0 z-30 flex flex-col items-center justify-center bg-black/80 backdrop-blur-sm animate-flicker">
                <div className="text-center space-y-6 max-w-md px-6">
                  <h1 className="text-6xl md:text-8xl font-creepy text-red-600 drop-shadow-[0_0_15px_rgba(255,0,0,0.5)]">
                    THE WOBBLY WATCHER
                  </h1>
                  <p className="text-xl font-retro text-gray-300">
                    You are small. It is wobbly.<br/>It wants a hug. Do NOT let it hug you.
                  </p>
                  
                  <div className="py-4 flex justify-center">
                    <Ghost className="w-16 h-16 text-purple-400 animate-bounce" />
                  </div>

                  <button 
                    onClick={startGame}
                    className="px-8 py-4 bg-red-700 hover:bg-red-600 text-white font-bold text-2xl font-retro rounded shadow-[0_0_20px_rgba(255,0,0,0.4)] hover:shadow-[0_0_40px_rgba(255,0,0,0.6)] hover:scale-105 transition-all active:scale-95"
                  >
                    START ESCAPE
                  </button>
                  <p className="text-xs text-gray-500 font-mono mt-4">
                    Use MOUSE or TOUCH to run.
                  </p>
                </div>
              </div>
            )}

            {gameState === 'GAME_OVER' && (
              <div className="absolute inset-0 z-40 flex flex-col items-center justify-center bg-red-900/90 backdrop-blur-md">
                <div className="text-center space-y-4 animate-shake">
                  <Skull className="w-24 h-24 mx-auto text-black mb-4" />
                  <h2 className="text-6xl font-creepy text-black drop-shadow-lg">
                    SQUISHED!
                  </h2>
                  <p className="text-2xl font-retro text-white">
                    You survived for <span className="text-yellow-300 text-4xl">{scoreSeconds}</span> seconds.
                  </p>
                  
                  <div className="mt-8">
                    <p className="text-lg font-creepy text-red-200 italic mb-6">
                      "You taste like blueberries and fear."
                    </p>
                    
                    <button 
                      onClick={startGame}
                      className="px-8 py-3 bg-black border-2 border-red-500 text-red-500 hover:bg-red-500 hover:text-black font-bold text-xl font-retro rounded transition-all uppercase"
                    >
                      Try Again?
                    </button>
                  </div>
                </div>
              </div>
            )}
          </div>
        );
      };

      // --- MOUNT ---
      const root = createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>